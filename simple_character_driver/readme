/*                                                               
# 191222 : 此範例執行步驟，已經可以執行
1) $make
2) ls : 確認編好的檔案
3) 載入module 「mydemo」 : sudo insmod mydemo.ko           ## 注意 : 是輸入檔>    案名稱(xxx.ko)
4) 查詢module 「mydemo」 : sudo lsmod | grep "mydemo"
sudo rmmod mydemo
5) 查詢有無成功 : dmesg 指令來察看系統日誌
[ 7938.150032] succeeded register char device: my_demo_dev
[ 7938.150033] Major number = 244, minor number = 0
6) cat /proc/devices
244 my_demo_dev
7) 手動生成device node : mknod "file name" "type" "major" "minor", c : character device
sudo mknod /dev/demo_drv c 244 0
8) ll /dev/
crw-r--r--   1 root    root    244,   0 十二 19 23:54 demo_drv
9) gcc test.c -o test; ./test; dmesg
[ 8255.113817] demodrv_open: major=244, minor=0
[ 8255.113820] demodrv_read enter
10) 手動移除 device node : sudo rm /dev/demo_drv
11) 移除 module 「mydemo」 : sudo rmmod mydemo               ## 注意 : 是輸入模>    組名稱(xxx)

===============================
# 191205 :

。設備號是系統中珍貴的資源。設備號 = 主設備號 + 次設備號。主設備號代表一類設備，次設備號代表同一類設備的不同個體。

。Linux系統中「萬物皆文件」。device node也是一個文件，用來連接kernel space device driver & user space process。

1) alloc_chrdev_region (常用) : 「自動」分配一個主設備號，可以避免和系統占用的主設備號重覆。

  。register_chrdev_region : 設備號申請。

2) cdev_alloc() : 產生struct cdev，也就是字元驅動的struct。

3) cdev_init() : 初始化 struct cdev，並建立該設備與file operation之間的連接關係。

4) cdev_add() : 把一個字元設備添加到系統中，通常在驅動程序的probe函數。

5) cdev_del() : 從系統中刪除一個 struct cdev。

6) unregister_chrdev_region : 把主設備號釋放給系統。

# 參考文件 :
  張天飛，笨叔叔，奔跑吧內核
  runninglinuxkernel_4.0/rlk_lab/rlk_basic/chapter_5
  chapter-5-lab1-实验说明
*/
